#####  Operating System Concept Notes

**操作系统概念**

旨在于

> + Understand different OS concepts This is where the Ops part coming in, earlier it was solely supported guys and sysadmin people who were responsible for knowing about OS and hardware, but with DevOps, now developer also needs to know them. You at least need to know about Process Management, Threads and Concurrency, Sockets, I/O Management, Virtualization, Memory storage and File systems as suggested in the roadmap. Since most of us work in Linux, I suggest you go through the Linux Administration BootCamp course on Udemy to learn and understand Linux OS better. -- [javinpaul dev.to](https://dev.to/javinpaul/the-2019-devops-engineering-roadmap-2klc)
>
> + Extend，CLI、Script
>
> + 简而言之，简单的了解操作系统概念。
>
>   从进程到线程、进程之间的通讯、读写管理、虚拟化、内存存储、文件系统、分布式系统。
>
>   个人额外附加计算机系统的 basic 、 cli 、scripts

**Note**

在节点 3 ~ 6 中只是处于了解的阶段，这个对于解决问题很有帮助，比如能够直到更深层次的问题和知识点，或许用不上，但是很有必要去了解它们（毕竟所有的工作都是基于此而运作的工作）。

> （ 硬件 - 驱动 - 内核 - 进程 - 线程 ）用户所看到的问题和操作界面。

最为接近于现实的计算机化服务是 1、2、6、7、8、9、10. 

> 1 是最为主要的，所有的计算机都会构建在于此上面。
>
> 2 作为一名信息化从业者，GUI 与不使用于服务器的管理，这是我需要用到的计算机用户界面 cli 。旨在于提高自己的处理速度和能力，在大部分的客户端环境中GUI 的作用是有限的。
>
> 6 对于内部的进程要有所了解，TCP/IP 就要加深了解。
>
> 7 虽然我本来就有学习过虚拟化，但是对于虚拟化的工作环境和流程，在这里可以得到进一步的提升。
>
> 8 对于内存工作原理的了解，更高的存储性能 “内存转存储”。
>
> 9 也是一个关于存储数据的问题点。
>
> 10 虽然这不是这个本文的内容，这是顺手写上去的，比较适合我的知识架构。

小结 ：处于了解的阶段。



##### 1. Computer Basic

> From [Basics of Computers - Introduction](https://www.tutorialspoint.com/basics_of_computers/basics_of_computers_introduction.htm)

> Input-Process-Output Model
>
> Computer input is called data and the output obtained after processing it, based on user’s instructions is called information. Raw facts and figures which can be processed using arithmetic and logical operations to obtain information are called data.

> ![Block Diagram](https://www.tutorialspoint.com/basics_of_computers/images/block_diagram.jpg)
>
> The basic parts of a computer are as follows 
>
> - Input Unit − Devices like keyboard and mouse that are used to input data and instructions to the computer are called input unit.
>
>
> - Output Unit − Devices like printer and visual display unit that are used to provide information to the user in desired format are called output unit.
>
>
> - Control Unit − As the name suggests, this unit controls all the functions of the computer. All devices or parts of computer interact through the control unit.
>
>
> - Arithmetic Logic Unit − This is the brain of the computer where all arithmetic operations and logical operations take place.
>
>
> - Memory − All input data, instructions and data interim to the processes are stored in the memory. Memory is of two types – primary memory and secondary memory. Primary memory resides within the CPU whereas secondary memory is external to it.

> 计算机系统是当代生活中比较常见的复杂系统之一。随着科技的发展，计算机系统正变得愈加成熟。
>
> 究其本质，计算机系统由硬件和软件两大部分组成。硬件的工作依靠软件的控制，软件的运行依托硬件的支持。两者相互依存，不可分割。
>
> 硬件指的是计算机的实体部分，也就是“看得见，摸得着”的部分，由各类电子元器件以及光、电、机等相关设备组成，包括主机和外设等。
>
> 现在最常见的计算机系统，是1945年编制的冯·诺依曼计算机。我们日常所指的计算机，基本都是冯·诺依曼计算机。读本所介绍的，也是冯·诺依曼计算机。
>
> From Wikipedia book

> ![linux体系结构](https://applied-programming.github.io/Operating-Systems-Notes/images/linuxarch.png)
> Linux Architecture （Form OS Notes）

**Note**

“计算机”由硬件和软件所组成，作为一名使用者和维护者，均要对其进行了解。

此处只是描述一下硬件方面的问题。

> + IO ，输入和输出的接口，外设、显示
> + 计算中心，显卡、中央处理器、以及相关的外设

对硬件的维护，需要了解：弱电、物理散热、电路版集成。（维护不等于维修 ！）

> + 扩展内存，主板支持的信息、兼容性。
> + 扩展显卡，对于电力功耗的计算、散热的需求等信息。
> + 硬件置换，根据硬件的支持性和可操作性，用于提升或置换相关计算机硬件。
> + 补充（这方面的内容，通常具备”客观性“，对于分析和处理可借助一定的方式或工具来接近此问题）
> + ······



##### 2. Command Line Interface

**Basic**

> The general pattern of an OS command line interface[[6\]](https://en.wikipedia.org/wiki/Command-line_interface#cite_note-Bash-6)[[7\]](https://en.wikipedia.org/wiki/Command-line_interface#cite_note-Microsoft_Windows-7) is:
>
> ```
> Prompt command param1 param2 param3 … paramN
> ```
>
> - [Prompt](https://en.wikipedia.org/wiki/Command-line_interface#Command_prompt) — generated by the program to provide context for the client.
> - Command — provided by the client. Commands are usually one of three classes:
>   1. *Internal* commands are recognized and processed by the command line interpreter itself and not dependent upon any external executable file.
>   2. *Included* commands run separate executable files generally considered part of the operating environment and always included with the OS.
>   3. *External* commands run executable files that are not part of the basic OS, but added by other parties for specific purposes and applications.
> - param1 … paramN — Optional parameters provided by the client. The format and meaning of the parameters depends upon the command issued. In the case of Included or External commands, the values of the parameters are delivered to the program (specified by the Command) as it is launched by the OS. Parameters may be either [Arguments](https://en.wikipedia.org/wiki/Command-line_interface#Arguments) or [Options](https://en.wikipedia.org/wiki/Command-line_interface#Command-line_option).
>
> In this example, the delimiters between command-line elements are [whitespace characters](https://en.wikipedia.org/wiki/Whitespace_character) and the end-of-line delimiter is the [newline](https://en.wikipedia.org/wiki/Newline) delimiter. This is a widely used (but not universal) convention for command-line interfaces.
>
> -- From Wikipedia

> In [computing](https://en.wikipedia.org/wiki/Computing), a **shell** is a computer program which exposes an [operating system](https://en.wikipedia.org/wiki/Operating_system)'s services to a human user or other program. In general, operating system shells use either a [command-line interface](https://en.wikipedia.org/wiki/Command-line_interface) (CLI) or [graphical user interface](https://en.wikipedia.org/wiki/Graphical_user_interface) (GUI), depending on a computer's role and particular operation. It is named a shell because it is the outermost layer around the operating system.[[1\]](https://en.wikipedia.org/wiki/Shell_(computing)#cite_note-Economist-1) [[2\]](https://en.wikipedia.org/wiki/Shell_(computing)#cite_note-JargonFile-2)
>
> Graphical shells place a low burden on beginning computer users, and are characterized as being easy to use. Since they also come with certain disadvantages, most GUI-enabled operating systems also provide CLI shells.
>
> -- From Wikipedia

Note

cli 就是一个人工交互（UI）的方式，通常也会要求使用者必须具备一定的基础。

这是啥呢 ? 以当下不健全的知识把它流程抽象解释为 ：硬件 - “黑盒” （或者是一个 Shell ）- UI - CLI

这个“黑盒”概况的很抽象，赋予其相关的含义：进程、线程、进程通讯、读写与性能、虚拟化、内存存储、磁盘存储、文件系统，在这些的内容的基础上就是脚本和“宏”、自动化的领域，这是一个很重要的基础条件。了解的内容越多，才能对上层应用进行操作和管理。

我需要一些“共识”来辅助，比如

> + “命令模板”
>
>   key -  value （keys - values）I  Prompt command param1 param2 param3 … param N
>
> + ”生存的基础条件“ Read cli help，比如 PowerShell 的 Get-Help
>
> + cli 与 API ，要理解这是一个操作、调整系统资源 API，也包含其他的服务

**需要用到的 “ Shell ”**

Microsoft PowerShell，当前最为擅长的 cli 

> 基础三件套
>
> >  Get-Command、Get-Help、 Get-Member（获取命令、帮助、方法）
>
> 更多请参阅 [PowerShell - docs](https://docs.microsoft.com/zh-cn/powershell/)

Windows Server Command（被迭代产品，用于辅助 PowerShell）

> 查看帮助 Example Command /?
>
> 更多请参阅 [Windows Commands - docs](https://docs.microsoft.com/zh-cn/windows-server/administration/windows-commands/windows-commands)

Unix-like Bash，处理了解阶段具备相关的基础知识

> **必须了解**
>
> >  whatis info man which whereis ，如同它 cli 命令一样，自助查看帮助、文档、搜索、使用 cli （Useful unix-like bash shell）。
>
>  有了解，但用的并不多，关于这方面使用相关的教程更为合适（Debian 为例），如下：
>
> [参考手册 zh-cn](https://www.debian.org/doc/manuals/debian-reference/index.zh-cn.html)
>
> [新维护者手册 zh-cn](https://www.debian.org/doc/manuals/maint-guide/index.zh-cn.html)



##### 3. Process Management

**Basic**

关于进程和进程管理

> **进程**（英语：process），是指计算机中已运行的[程序](https://zh.wikipedia.org/wiki/程式)。进程曾经是[分时系统](https://zh.wikipedia.org/wiki/分時系統)的基本运作单位。在面向进程设计的系统（如早期的[UNIX](https://zh.wikipedia.org/wiki/UNIX)，[Linux](https://zh.wikipedia.org/wiki/Linux) 2.4及更早的版本）中，进程是程序的基本执行实体；在面向线程设计的系统（如当代多数操作系统、[Linux](https://zh.wikipedia.org/wiki/Linux) 2.6及更新的版本）中，进程本身不是基本运行单位，而是[线程](https://zh.wikipedia.org/wiki/執行緒)的容器。
>
> 在现代[操作系统](https://zh.wikipedia.org/wiki/作業系統)中，**行程管理**（英语：Process management）是操作系统的功能之一，特别是[多任务处理](https://zh.wikipedia.org/wiki/多任务处理)的状况下，这是必要的功能。操作系统将资源分配给各个[行程](https://zh.wikipedia.org/wiki/行程)，让进程间可以分享与交换信息，保护每个行程拥有的资源，不会被其他行程抢走，以及使进程间能够同步。为了达到这些要求，操作系统为每个行程分配了一个数据结构，用来描述行程的状态，以及行程拥有的资源。操作系统可以透过这个数据结构，来控制每个行程的运作。

Note

在应用面上，基础级为 Process ，为了提高效率内部嵌套 Threads ，对于前面的两个进行整合和管理就形成了并发（Concurrency）。所以这三个知识面要一起上。

**Windows Process**

> [Processes And Threads -- Microsoft docs](https://docs.microsoft.com/en-us/windows/win32/procthread/processes-and-threads)
>
> [Process-explorer （Program）- Microsoft docs](https://docs.microsoft.com/en-us/sysinternals/downloads/process-explorer)
>
> Program ： Task Manage、Process-explorer

**Unix-Like Process**

> [Unix / Linux - Processes Management](https://www.tutorialspoint.com/unix/unix-processes.htm)
>
> Program ：bash > ps or more ”shell program“



##### 4. Threads and Concurrency

> **线程**（英语：thread）是[操作系统](https://zh.wikipedia.org/wiki/操作系统)能够进行运算[调度](https://zh.wikipedia.org/wiki/调度)的最小单位。大部分情况下，它被包含在[进程](https://zh.wikipedia.org/wiki/进程)之中，是[进程](https://zh.wikipedia.org/wiki/进程)中的实际运作单位。一条线程指的是[进程](https://zh.wikipedia.org/wiki/进程)中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。在[Unix System V](https://zh.wikipedia.org/wiki/Unix)及[SunOS](https://zh.wikipedia.org/wiki/SunOS)中也被称为轻量进程（lightweight processes），但轻量进程更多指内核线程（kernel thread），而把用户线程（user thread）称为线程。
>
> **多线程**（英语：**multithreading**），是指从[软件](https://zh.wikipedia.org/wiki/软件)或者[硬件](https://zh.wikipedia.org/wiki/硬件)上实现多个[线程](https://zh.wikipedia.org/wiki/线程)并发执行的技术。具有多线程能力的计算机因有硬件支持而能够在同一时间执行多于一个[线程](https://zh.wikipedia.org/wiki/线程)，进而提升整体处理性能。具有这种能力的系统包括[对称多处理机](https://zh.wikipedia.org/wiki/对称多处理机)、[多核心](https://zh.wikipedia.org/wiki/多核心)处理器以及[芯片级多处理](https://zh.wikipedia.org/wiki/芯片级多处理)（Chip-level multithreading）或[同时多线程](https://zh.wikipedia.org/wiki/同时多线程)（Simultaneous multithreading）处理器。
>
> 在[计算机科学](https://zh.wikipedia.org/wiki/计算机科学)中，**并发性**（英语：Concurrency）是指在一个系统中，拥有多个计算，这些计算有同时执行的特性，而且他们之间有着潜在的交互。因此系统可进行的运行路径会有相当多个，而且结果可能具有不确定性。[并发计算](https://zh.wikipedia.org/wiki/并发计算)可能会在具备[多核心](https://zh.wikipedia.org/wiki/多核心)的同一个芯片中复合运行，以[优先分时](https://zh.wikipedia.org/wiki/优先权)[线程](https://zh.wikipedia.org/wiki/线程)在同一个处理器中运行，或在不同的处理器执行。

对于线程的认知更多的在于学习 Python 的时候，单次运行只有一个结果就是单线程，单次运行多次结果则为多线程。线程的知识也不是限制于此。

比如，并发

> 并发的本质是时间上重叠，那么就需要其对资源进行并发访问。但是由我们之前概括的，进程之间很难共享资源，因为彼此的内存是独立的。
>
> 但是线程就没有这个问题。为什么？因为所有的线程是共享一块虚拟内存的，也就是从线程的角度而言，其看到的物理资源都是一样的。那么共享内存就可以直接解决线程通信的问题。而线程也表示一个独立的逻辑流。

再者，线程间同步

> 1. 互斥量（Mutex）：互斥量，只有拥有互斥对象的线程才可以访问，因为互斥对象只有一个，所以可以保证公共资源不被多个线程同时访问。比如Java之中的Synchronized 和各种 Lock 都是这种机制。
> 2. 信号量（Semphares）：允许多个线程访问同一个资源
> 3. 事件（Event）：Wait/Notify：通过通知操作的方式来保持多线程的同步，还可以方便的实现多线程优先级的比较操作。

实际中接触最多的线程和并发应用就是 Python，如果让我来使用 PowerShell 或者 bash 来实现多线程，貌似没有试过，或者需要重新认识。但这不是难度，因为以前有接触个这方面的内容，需要一些时间来处理这个。目前不过是有了一个初步了解而已。

关于 Python 并发的上手教程

> [oncurrency-with-processes-threads-and-coroutines](https://learnku.com/docs/pymotw/concurrency-with-processes-threads-and-coroutines/3418)

##### 5. Sockets

了解

> Sockets allow communication between two different processes on the same or different machines. To be more precise, it's a way to talk to other computers using standard Unix file descriptors. In Unix, every I/O action is done by writing or reading a file descriptor. A file descriptor is just an integer associated with an open file and it can be a network connection, a text file, a terminal, or something else.
>
> To a programmer, a socket looks and behaves much like a low-level file descriptor. This is because commands such as read() and write() work with sockets in the same way they do with files and pipes.

有一些疑问

> - 进程之间是如何通讯  ？ 
>
>   Read 、Write （即计算机的 IO 为底层，在系统中对其进行复用）
>
>   大部分由系统进行管理，发送可读、可写，然后加“中间管理器”，这样就可以通讯了。（让我想到一句话，一个计算机问题可以用一个”中间件“来解决，这里就是在底层和用户层之间）。所以它们是如何通讯的 ？<u>看下面 socket 的基本流程。</u>
>
> - 它们如何共享内部的计算机资源 ？
>
>   重复，pass。（既然已经可以交流了，拿共享资源也不再话下了）
>
>   举例子，比如神奇的虚拟机快照，不用关机、不用停止服务，把它整个“基础文件”拿出来，再导入另一台主机中，同样可以运行。那一块“VHD”就是“资源”，我可以复用、或容灾，另一个角度而言“即包含资源共享”。
>
> - 计算之间如何使用 Sockets 与其他计算机通讯 ？
>
>   重定向至 TCP / IP  、HTTP （不在此篇笔记内）。

Sockets 基本流程

> 一个socket通讯建立的基本流程
>
> - 客户端(client)
>   - 创建一个socket (socket())
>   - 把socket连接到server的地址上(也许是IP，也许是本地的一个文件) ( connect())
>   - 接收/写数据 (read/write)
> - 服务端(server)
>   - 创建一个socket
>   - 把socket绑定到某个地址上，互联网的socket是ip地址加端口号，本地socket是一个文件地址
>   - 监听socket上的连接(listen)
>   - 监听到连接后，接收连接(accept())
>   - 接受/写数据

"插座"的功能

> - **Stream Sockets** − Delivery in a networked environment is guaranteed. If you send through the stream socket three items "A, B, C", they will arrive in the same order − "A, B, C". These sockets use TCP (Transmission Control Protocol) for data transmission. If delivery is impossible, the sender receives an error indicator. Data records do not have any boundaries.
> - **Datagram Sockets** − Delivery in a networked environment is not guaranteed. They're connectionless because you don't need to have an open connection as in Stream Sockets − you build a packet with the destination information and send it out. They use UDP (User Datagram Protocol).
> - **Raw Sockets** − These provide users access to the underlying communication protocols, which support socket abstractions. These sockets are normally datagram oriented, though their exact characteristics are dependent on the interface provided by the protocol. Raw sockets are not intended for the general user; they have been provided mainly for those interested in developing new communication protocols, or for gaining access to some of the more cryptic facilities of an existing protocol.
> - **Sequenced Packet Sockets** − They are similar to a stream socket, with the exception that record boundaries are preserved. This interface is provided only as a part of the Network Systems (NS) socket abstraction, and is very important in most serious NS applications. Sequenced-packet sockets allow the user to manipulate the Sequence Packet Protocol (SPP) or Internet Datagram Protocol (IDP) headers on a packet or a group of packets, either by writing a prototype header along with whatever data is to be sent, or by specifying a default header to be used with all outgoing data, and allows the user to receive the headers on incoming packets.

计算机与计算机之间

> Sockets 用于不在一台机器上面的进程进行通信，很典型的就是 TCP/IP 

对于计算机与计算机之间的通讯就在网路的知识中学习，比如 TCP/IP 就是最好的选择。

> 此处故意留空 ！



##### 6. I/O Management

IO 工作原理

优化现有的 IO 性能，借用如下文字：

> **IO Management Operating System**
>
> - Has protocols
>   - Interfaces for device I/O
> - Has dedicated handlers
>   - Device drivers, interrupt handlers
> - Decouple I/O details from core processing
>   - abstract I/O device detail from applications
>
> **Disk access optimizations** （关于优化的问题）
>
> ​	Reducing file access overheads
>
> 1. Caching/buffering : reduce number of disk accesses
>    - buffer cache in main menu
>    - read/write from cache
>    - periodically flush to disk - fsync()
> 2. I/O scheduling : reduce disk head movement
>    - maximize sequential vs random access
> 3. Prefetching : increases cache hits
>    - leverages locality
> 4. Journaling/logging: reduce random access (ext3, ext4)
>    - "describe" write in log : block, offset, value..
>    - periodically apply updates to proper disk locations
>
> From https://github.com/Aniruddha-Tapas/Operating-Systems-Notes

Note

在已知答案的情况下，未必能够直接做到“ IO 优化”。

了解基础的硬件所带来的 IO 性能，最为简单的划分就是 Read And Write。进一步了解基础设备，比如 CPU 的计算、内存的访问、外置设备的读写、线程与进程 ... 还有更多的知识需要了解。

> + 比如 Win 如何在不断电的情况下入拆除硬盘，禁用设备后拆除磁盘（没有保障，不保证一定适用 ！）
> + 虚拟磁盘数据备份的读取优化
> + ”内存存储“的管理，比如软件缓存、SQL 缓存 ... 



##### 7. Virtualization

在另外的笔记中有记录

> 计算机的虚拟化、计算机虚拟化的应用 Dockers 两个笔记，不重复累述

诸如

> 在某种角度上，它是一种“资源管理技术”，它可以很好的帮助你了解虚拟化
>
> 虚拟化的服务集群并非无中生有，它是“一种资源管理技”，网络、集群、网卡、安全、存储、迁移、备份、服务、管理等资源集合管理，虚拟化再商业化中有着较为完整技术方案，基础知识关系到各个子领域的计算机基础中。请继续熟悉它们的核心，对比“虚拟机”和实体主机之间的优劣势，感受“虚拟化”所带来的进步与发展。

在一个计算机的机上运行多个系统，或者多台计算机运行集群的系统化。

在认识虚拟化之前要对基础的计算机有所了解。

当然利用起来也需要一定的基础知识，对虚拟化平台的知识和使用、及管理。

“主机”虚拟化

> + （VMware vShere）VMware ESXi + VMware Vcenter
> + Hyper-V + Microsoft Admin Center
>
> “容器”虚拟化，Kubernetes + Docker
>
> 内核虚拟化，Unix-like - KVM



##### 8. Memory Storage

> 又一个很强的底层技术，标记其为了解。

在客户端应用层上，或许会更加专注于”存储方面“ ：比如硬盘文件缓存加速、更快的存储读取（使用内存的数据库） ... More



##### 9. File Systems

-tag # 了解即可

**Disk And RAID** （存储数据）

> [了解 RAID - cnblogs](https://www.cnblogs.com/chuncn/p/6008173.html)

单块的硬盘性能和容量有限，把它们“集中”，共同利用。既有针对于存储、容灾、性能等不同的方案，作为用户端也可以选择硬件、或软件的方式，用于服务当前的服务。具体而言有需求就会有答案，根据不同的需求定制相对应的方案即可。因为目前的 RAID 技术已经很成熟了，除非发行了新的标准技术。

**System File**（存储系统）

> [了解 File System - xhinliang`s Blog](https://xhinliang.win/2018/11/10/computer/frequent-series/frequent-fs-intro/) 

这个较为系统层的数据结构，旨在于适用于不同的业务类型，比如有数据库专用的文件格式、为系统而设计的格式、已及 Windows 那个统一的设计。如果没有特殊的需求，直接使用该系统发行版默认的文件格式即可。

**Distributed File System** （以上两个的集合点，计算机“资源集群”）

>  [了解 Distribute File System - cnblogs](https://www.cnblogs.com/youngerchina/p/5624459.html)

基于以上两个点，针对于存储和计算机性能、及容灾性。具备代表性的有 Windows Server Ad + dc（主域与附属域）、服务器虚拟化集群（Vmware、Hyper-V）都包含了相关的“分布式”计算机化系统服务。



##### 10. Distributed System

关于分布式系统

> 在[计算机科学](https://zh.wikipedia.org/wiki/計算機科學)中，**分布式计算**（英语：Distributed computing），又译为**分散式运算**。这个研究领域，主要研究**分布式系统**（Distributed system）如何进行计算。分布式系统是一组[电脑](https://zh.wikipedia.org/wiki/電子計算機)，透过[网络](https://zh.wikipedia.org/wiki/計算機網絡)相互连接[传递消息](https://zh.wikipedia.org/wiki/訊息傳遞_(軟體))与通信后并协调它们的行为而形成的系统。[[1\]](https://zh.wikipedia.org/wiki/分布式计算#cite_note-Coulouris-1)组件之间彼此进行交互以实现一个共同的目标。把需要进行大量计算的工程数据分割成小块，由多台[计算机](https://zh.wikipedia.org/wiki/電子計算機)分别计算，再上传运算结果后，将结果统一合并得出数据结论的科学。分布式系统的例子来自有所不同的[面向服务的架构](https://zh.wikipedia.org/wiki/面向服务的架构)，[大型多人在线游戏](https://zh.wikipedia.org/wiki/大型多人線上遊戲)，[对等网络](https://zh.wikipedia.org/wiki/对等网络)应用。 From Wikipedia

> 分布式系统是由一组通过网络进行通信、为了完成共同的任务而协调工作的计算机节点组成的系统。分布式系统的出现是为了用廉价的、普通的机器完成单个计算机无法完成的计算、存储任务。其目的是 **利用更多的机器，处理更多的数据**。 from cnblog

会面临的问题

> 分布式系统需要大量机器协作，面临诸多的挑战：
>
> 第一，异构的机器与网络：
>
> 分布式系统中的机器，配置不一样，其上运行的服务也可能由不同的语言、架构实现，因此处理能力也不一样；节点间通过网络连接，而不同网络运营商提供的网络的带宽、延时、丢包率又不一样。怎么保证大家齐头并进，共同完成目标，这四个不小的挑战。
>
> 第二，普遍的节点故障：
>
> 虽然单个节点的故障概率较低，但节点数目达到一定规模，出故障的概率就变高了。分布式系统需要保证故障发生的时候，系统仍然是可用的，这就需要监控节点的状态，在节点故障的情况下将该节点负责的计算、存储任务转移到其他节点
>
> 第三，不可靠的网络：
>
> 节点间通过网络通信，而网络是不可靠的。可能的网络问题包括：网络分割、延时、丢包、乱序。
>
> 相比单机过程调用，网络通信最让人头疼的是超时：节点A向节点B发出请求，在约定的时间内没有收到节点B的响应，那么B是否处理了请求，这个是不确定的，这个不确定会带来诸多问题，最简单的，是否要重试请求，节点B会不会多次处理同一个请求。
>
> 总而言之，分布式的挑战来自不确定性，不确定计算机什么时候crash、断电，不确定磁盘什么时候损坏，不确定每次网络通信要延迟多久，也不确定通信对端是否处理了发送的消息。而分布式的规模放大了这个不确定性，不确定性是令人讨厌的，所以有诸多的分布式理论、协议来保证在这种不确定性的情况下，系统还能继续正常工作。from cnblog

有关“分布式”的理论、组件、协议

> 用户使用Web、APP、SDK，通过HTTP、TCP连接到系统。在分布式系统中，为了高并发、高可用，一般都是多个节点提供相同的服务。那么，第一个问题就是具体选择哪个节点来提供服务，这个就是负载均衡（load balance）。负载均衡的思想很简单，但使用非常广泛，在分布式系统、大型网站的方方面面都有使用，或者说，只要涉及到多个节点提供同质的服务，就需要负载均衡。
>
> 通过负载均衡找到一个节点，接下来就是真正处理用户的请求，请求有可能简单，也有可能很复杂。简单的请求，比如读取数据，那么很可能是有缓存的，即分布式缓存，如果缓存没有命中，那么需要去数据库拉取数据。对于复杂的请求，可能会调用到系统中其他的服务。from cnblog

Note 

通过以上的描述可以得知，计算机基础很重要，在处理“分布式系统”问题的时候，需要学习相关的运作协议的标准（或许了解其工作原理）、了解网络知识、基础上维护计算机节点 ... 。更多的计算机中间件和协议，意味着会面临更多的问题。

> 需要用到时，再进一步深入了解和使用、并管理。



##### 11. Scripts

这是我了解和使用中的脚本 Python、PowerShell、Shell 有两个是针对于不同的系统脚本语言，在哪一个层面就是用哪一个知识块。Python 本身是一个胶水程序，在自动化方面很重要，至少会使用它之后它给我带来更多的便利和更多的方法。

> 我也在其他的笔记中记录过 Python 和 PowerShell ，此处不作累述。
>
> 至于 bash shell 作为一个扩展，用到就会继续的学习和使用、以及扩展。

此处引用书籍或文档（个人看过的）

> + 流畅的 Python ，好书，需购买，大学在图书馆中已阅
> + PowerShell 101，入门好教材 Microsoft Docs 中就能够看到
> +  Linux Tools Quick Tutorial，入门好教材，社区版文档，开源和免费

主要的应用面在于“批处理”（宏、或者称其为自动化），利用计算机的资源和相关的编程语言及脚本，把重复的工作内容简化为相关的“流水线化“，把重复的工作交给计算机进行处理，这是我的计算机信条之一。

这方面的的说明和记录已经有了，此处就简单点名一下。

> + Python ：文本格式化、信息服务检查、网络编程、操作计算机 API（基于 PIP Package）... 
> + PowerShell ：服务器管理、系统信息收集 ...
> + Windows Batch ：Auto Task、注册表管理、系统服务管理 ...
> + Unix-like Shell ：NAS、AP、Ubuntu、Debian 的管理和使用 ...



##### X. Appendix

##### Reference

Microsoft Docs

[./ Microsoft Docs zh-cn](https://docs.microsoft.com/zh-cn/)

[./ Processes And Threads - Microsoft docs](https://docs.microsoft.com/en-us/windows/win32/procthread/processes-and-threads)

Wikipedia

[./ 计算机组成原理](https://zh.m.wikibooks.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86)

[./ Process _(computing)](https://en.wikipedia.org/wiki/Process_(computing))

[./ Process_management_(computing)](https://en.wikipedia.org/wiki/Process_management_(computing))

More docs

[Basics of Computers - Introduction](https://www.tutorialspoint.com/basics_of_computers/basics_of_computers_introduction.htm)

[Operating System Notes - doc](https://applied-programming.github.io/Operating-Systems-Notes/) 

[Linux Tools Quick Totorial -doc](https://doc.yonyoucloud.com/doc/linuxtools-rst-latest/index.html)

More blog

[IO-hardware - Mbinary's Blog](https://mbinary.xyz/IO-hardware.html)

[了解 File System - xhinliang`s Blog](https://xhinliang.win/2018/11/10/computer/frequent-series/frequent-fs-intro/) 

[Process、Threads And Sockets - Timzhouyes's Blog](https://timzhouyes.github.io/2020/04/11/%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E5%92%8C%E9%80%9A%E4%BF%A1/)

[了解 RAID - cnblogs](https://www.cnblogs.com/chuncn/p/6008173.html)

[了解 Distribute File System - cnblogs](https://www.cnblogs.com/youngerchina/p/5624459.html)

[了解 Distribute System - cnblogs](https://www.cnblogs.com/xybaby/p/7787034.html)

[了解 Sockets of C#  - cnblogs](https://www.cnblogs.com/dolphinx/p/3460545.html)

[了解 Sockets of C++ / Linux - Blurredcode`blog](https://www.blurredcode.com/2020/03/linux%E7%9A%84socket%E6%8C%87%E5%8C%97/#fn:1) 

More other

[What is socket ? ](https://www.tutorialspoint.com/unix_sockets/what_is_socket.htm) 